[{"authors":null,"categories":null,"content":" Types of contributions Thanks for your interest in the Eclipse Keypop® project.\nThere are several ways to contribute to the project:\nPropose a fix for a problem that is already known or that you have identified. In this case you will have to notify the issue in the repository where the problem appeared and reference the issue in all the other repositories affected by the fix. Propose the creation of a new component. In this case you will first have to create an issue in the repository https://github.com/eclipse-keypop to justify the need and request the creation of a new repository, wait for the issue to be resolved by the decision of the committers, and then create an issue in the new repository signifying the start of development of the new component. Eclipse Contributor Agreement Before your contribution can be accepted by the project team contributors must electronically sign the Eclipse Contributor Agreement (ECA).\nhttp://www.eclipse.org/legal/ECA.php Commits that are provided by non-committers must have a Signed-off-by field in the footer indicating that the author is aware of the terms by which the contribution has been provided to the project. The non-committer must additionally have an Eclipse Foundation account and must have a signed Eclipse Contributor Agreement (ECA) on file.\nFor more information, please see the Eclipse Committer Handbook: https://www.eclipse.org/projects/handbook/#contributing\nContributing via fork Check if there is already a GitHub issue for what you want to work on or create one. Announce in the comments section that you want to work on the issue. Also describe the solution you want to implement. To improve the chances for your contribution to be accepted, you’ll want to wait for the feedback of the committers. Fork the repository. Create a new branch from main for your changes. Name it after the issue number, e.g. #XXX_[description_of_changes]. Implement your changes. Rebase on main. Run ./gradlew spotlessApply to format the code and add licence headers to the files. Run ./gradlew build (to check code formatting and run tests) Commit your changes using the -s flag in order to add a Signed-off-by footer as mentioned above and use the same email address you are using for your GitHub account.\nUse commits messages that respect the commits message conventions. Push your changes to your forked repository. Submit a pull request referencing the related issue(s). After submitting, do not use your branch for any other development, otherwise further changes that you make will be visible in the PR. Contributing as a project committer Check if there is already a GitHub issue for what you want to work on or create one. Assign the issue to yourself. Create a new branch from main for your changes. Name it after the issue number, e.g. #XXX_[description_of_changes]. Implement your changes. Rebase on main. Run ./gradlew spotlessApply to format the code and add licence headers to the files. Run ./gradlew build (to check code formatting and run tests) Commit your changes. Use commits messages that respect the commits message conventions. Push the branch into the repository. Submit a pull request and ask somebody who is familiar with the code you modified to review it. If the reviewer approves and all checks are OK, merge using squash \u0026amp; commit method. Commits message conventions In order to ensure good readability of the commit history, it is necessary to have consistency in the structure of the commit messages.\nTherefore, all contributors to the project are asked to respect the structure of the commits messages as described in the guide Conventional Commits 1.0.0:\n\u0026lt;type\u0026gt;[optional scope]: \u0026lt;description\u0026gt; [optional body] \u0026lt;footer(s)\u0026gt; Furthermore, it is requested to indicate in the footer section the associated issue(s) that will be closed (Closes #xxx, closes #yyy, etc...). This will automatically close the associated issue(s) when the pull request is validated (see GitHub Docs for more details).\nIt is also required to indicate possible references to other associated issues (Refs: #aaa, #bbbb, repository_owner/other_repository_name#ccc, etc...).\nHere is fictive example:\nfeat(observation): allow asynchronous notification of reader events Add a public method in the observable reader to enable asynchronous notifications. Closes #34, closes #38 Refs: #12, eclipse-keypop/keypop-website#54 ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1693581209,"objectID":"03b6ed671df847a7fe95d07d922cdb1a","permalink":"https://keypop.org/community/contributing/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/community/contributing/","section":"community","summary":"Find out how to contribute to the Keypop project and how it can benefit your organization.","tags":null,"title":"How to contribute to Eclipse Keypop® project","type":"book"},{"authors":null,"categories":null,"content":" This page serves as a centralized hub, bringing a dynamic chronological overview that showcases the progress and updates across all Keypop components repositories. Date Component 2024-01-10Keypop Calypso Crypto Legacysam Java Api0.4.0Added LegacySamStaticUnlockDataProviderSpi, an SPI to provide SAM unlock data in static mode. LegacySamDynamicUnlockDataProviderSpi, an SPI to provide SAM unlock data in dynamic mode. New methods added to LegacySamSelectionExtension: setStaticUnlockDataProvider(LegacySamStaticUnlockDataProviderSpi unlockDataProvider) sets the unlock data provider for the static mode when the card reader becomes available at a later stage. setStaticUnlockDataProvider(LegacySamStaticUnlockDataProviderSpi unlockDataProvider, CardReader targetSamReader) sets the unlock data provider and the target SAM reader for the static mode when the target SAM reader is initially available. setDynamicUnlockDataProvider(LegacySamDynamicUnlockDataProviderSpi unlockDataProvider) sets the unlock data provider for the dynamic mode when the card reader becomes available at a later stage. setDynamicUnlockDataProvider(LegacySamDynamicUnlockDataProviderSpi unlockDataProvider, CardReader targetSamReader) sets the unlock data provider and the target SAM reader for the dynamic mode when the target SAM reader is initially available. Fixed The allowed length for unlocking data in static mode is 16 bytes only as expected by the SAM (setUnlockData method). 2023-11-27Keypop Calypso Crypto Legacysam Java Api0.3.0⚠️ The project has been migrated from the Calypsonet Terminal Calypso Crypto Legacy SAM API GitHub repository.\nAdded LegacySamApiFactory centralizes the methods used to create instances of the various interfaces of the API. CardTransactionLegacySamExtension extends the SPI CardTransactionCryptoExtension provided by “Keypop Calypso Card API” to extends a card transaction with specific SAM features (e.g. signature computation, etc.). New methods added to LegacySamSelectionExtension: setUnlockData(String unlockData, LegacySam.ProductType productType) sets the unlock data to be used to unlock a SAM C1 (8 or 16 bytes) and schedules the execution of the “Unlock data” command in the first position. prepareReadSystemKeyParameters(SystemKeyType systemKeyType) schedules the execution of a “Read Key Parameters” command for a system key. prepareReadCounterStatus(int counterNumber) schedules the execution of a “Read Event Counter” and “Read Ceiling” commands to read the status of a counter. prepareReadAllCountersStatus() schedules the execution of a “Read Event Counter” and “Read Ceiling” commands to read the status of all counters. New method added to LegacySam: getCounterIncrementAccess(int counterNumber) returns the counter increment access mode. Changed The project license is now “MIT License” (previously “Eclipse Public License 2.0”). CI: The Gradle plugin org.eclipse.keyple:keyple-gradle:0.2.+ has been replaced by org.eclipse.keypop:keypop-gradle:0.1.+. Renamed: Artifact org.calypsonet.terminal:calypsonet-terminal-calypso-crypto-legacysam-java-api -\u0026gt; org.eclipse.keypop:keypop-calypso-crypto-legacysam-java-api Package org.eclipse.keypop.calypso.card.crypto.legacysam -\u0026gt; org.eclipse.keypop.calypso.crypto.legacysam Interface LegacySamSelection -\u0026gt; LegacySamSelectionExtension Interface LSSecuritySetting -\u0026gt; SecuritySetting Interface LSFreeTransactionManager -\u0026gt; FreeTransactionManager Interface LSAsyncTransactionCreatorManager -\u0026gt; AsyncTransactionCreatorManager Interface LSAsyncTransactionExecutorManager -\u0026gt; AsyncTransactionExecutorManager Interface LSRevocationServiceSpi -\u0026gt; LegacySamRevocationServiceSpi All legacy factories were merged into a single factory LegacySamApiFactory: LegacySamSelectionFactory LSTransactionManagerFactory LSSecuritySettingFactory LSCardTransactionCryptoExtensionFactory LSCommandDataFactory Method signature refactored: LSWriteTransactionManager.prepareWriteCounterConfiguration(int counterNumber, int ceilingValue, boolean isManualCounterIncrementAuthorized) -\u0026gt; WriteTransactionManager.prepareWriteCounterConfiguration(int counterNumber, int ceilingValue, CounterIncrementAccess counterIncrementAccess). The enum CounterIncrementAccess has been created for this purpose. TraceableSignatureComputationData.withSamTraceabilityMode(int offset, boolean usePartialSamSerialNumber) -\u0026gt; TraceableSignatureComputationData.withSamTraceabilityMode(int offset, SamTraceabilityMode samTraceabilityMode). The enum SamTraceabilityMode has been created for this purpose. TraceableSignatureVerificationData.withSamTraceabilityMode(int offset, boolean isPartialSamSerialNumber, LSRevocationServiceSpi samRevocationService) -\u0026gt; TraceableSignatureComputationData.withSamTraceabilityMode(int offset, SamTraceabilityMode samTraceabilityMode, LegacySamRevocationServiceSpi samRevocationService). The enum SamTraceabilityMode has been created for this purpose. Removed The filterByProductType(LegacySam.ProductType productType) and …","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1693581209,"objectID":"9df4882bff6799b05e0bb341234f8f66","permalink":"https://keypop.org/community/changelog/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/community/changelog/","section":"community","summary":"This page serves as a centralized hub, bringing a dynamic chronological overview that showcases the progress and updates across all Keypop components repositories.","tags":null,"title":"Changelog","type":"book"},{"authors":null,"categories":null,"content":" Contributing Find out how to contribute to the Keypop project and how it can benefit your organization.\nChangelog This page serves as a centralized hub, bringing a dynamic chronological overview that showcases the progress and updates across all Keypop components repositories.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1693581209,"objectID":"460964d71a5606848132aa51ae04f454","permalink":"https://keypop.org/community/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/community/","section":"community","summary":"Contributing Find out how to contribute to the Keypop project and how it can benefit your organization.\nChangelog This page serves as a centralized hub, bringing a dynamic chronological overview that showcases the progress and updates across all Keypop components repositories.","tags":null,"title":"Community","type":"book"},{"authors":null,"categories":null,"content":" Keypop offers a set of interfaces based on the specifications from the Calypso Networks Association, for the creation of software components dedicated to the management of smart card readers and smart card applications.\nThe diagram below shows the dependencies between the client application, the Keypop APIs and their implementations:\nKey points:\nIndependent Lifecycle: Each API follows its own distinct lifecycle. Interface-Exclusive: APIs exclusively consist of interfaces. Public APIs: Some APIs are intended to be used by application developers. Internal Usage: Some APIs are dedicated to internal use, and intended to developers of Keypop-based implementations. ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1693581209,"objectID":"43c0c4121ee50066f7d192a6504d86bf","permalink":"https://keypop.org/apis/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/apis/","section":"apis","summary":"General presentation of the dependencies between the different Keypop APIs.","tags":null,"title":"Keypop architecture - APIs \u0026 software layers","type":"book"},{"authors":null,"categories":null,"content":" Overview As part of the Reader Layer, the Reader API provides high-level functionality for identifying, monitoring, configuring readers and process card selection scenarios.\nThe documentation for the specification produced by the Calypso Networks Association, on which this API is based, is available here.\nInterfaces The Reader API is a high-level interface used by terminal applications to operate smart card readers, it:\nprovides the means to identify card readers and verify the presence of smart cards.\noffers the possibility to configure the observation of readers in order to be notified on card insertion or withdrawal.\nis the entry point to manage the selection of a smart card in a specific reader.\nReader identification Any smart card reader entity should be accessible through an implementation of the CardReader interface. Each is defined with a specific name. A reader could be designed to operate contactless card or a contact card. Finally, this interface can inform about the presence of a card in the reader.\nConfigurableCardReader A reader with the capability to configure the communication protocols with smart card (contactless or contact) could implement the ConfigurableCardReader interface to activate or deactivate some communication protocols.\nReader observation If a reader has the ability to dynamically detect changes on the card presence, then it can also implement the interface ObservableCardReader.\nObservers implementing the CardReaderObserverSpi could be declared to an observable card reader to be notified on specific CardReaderEvent: card insertion, card selection (matched), or card removal.\nCard Selection The CardSelectionManager provides the possibility to prepare a request that could contain one or several card application selections.\nThe CardSelection SPI interface could be extended by the API of a specific smart card solution to improve the selection request with settings specific to the smart card solution.\nThrough the card selection manager, the prepared card selections could be managed in\nsynchronously: processed directly on a specific card reader on which a card is already present,\nor asynchronously: scheduled on a specific observable reader in order to be operated dynamically in case of card insertion detection.\nIf several card selections are prepared, the card selection manager operate the card selection in the order of preparation. By default, the card selection manager stops the card selection processing on the first successful card selection, and the logical channel is kept open.\nIn case the multiple selection mode is activated during the preparation, the card selection manager tries to operate ‘all’ the prepared selections, even if one or several of them are successful. If the last selection is successful, the logical channel could be kept open with the last selected application.\nduring the card selection preparation, it could also be explicitly requested to close the logical channel after the card selection.\nMoreover, it is possible to export/import a selection scenario in JSON format.\nCard selection modes Depending on the card transaction use case, or on the reader capability, there are two ways to manage the selection of a card:\nEither synchronously on a simple reader, a selection could be operated directly by transmitting the card selection scenario. In this case the same entity manages both the card selection and the card processing. Otherwise asynchronously on an observable reader, a scheduled card selection could be defined. In this case the card selection is operated automatically at the insertion of the card. In this case, the card selection is next managed by the observable reader, but the card processing is managed by a reader observer. Reader API - Card Selection Modes - Activity Diagram Observable reader states An observable reader is active only when at least one reader observer is registered, and if the start of the detection has been requested. When active, an observable reader could switch between three internal states:\nWait for card insertion Wait for card processing Wait for card removal In the nominal case, a reader observer indicates to the observable reader that the processing of the card is finished by releasing the card channel. To manage a failure of the reader observer process, the observable reader interface provides also a method to finalize the card processing.\nReader API - Observable Reader States - Activity Diagram The states could be switched:\ndue to an explicit API request (blue arrows): the release of the card channel, the call of an observable reader method: the addition or the remove of an observable reader, a request to start or stop the detection, to finalize the card processing. Or because of an external event (red arrows), the insertion or the remove of a card. the insertion of a card causing the observable reader to notify a CARD_MATCHED reader event (in case of successful scheduled selection) or a CARD_INSERTED reader event (notification …","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1700845823,"objectID":"31e99306539cbdaaf106f0d6caaec0bb","permalink":"https://keypop.org/apis/keypop-reader-api/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/apis/keypop-reader-api/","section":"apis","summary":"Public API which defines the elements shared by the reader.","tags":null,"title":"Keypop Reader API","type":"book"},{"authors":null,"categories":null,"content":" Overview The Card API is the communication interface between the Reader Layer and the Card Layer (e.g. Calypso Card API).\nThe documentation for the specification produced by the Calypso Networks Association, on which this API is based, is available here.\nInterfaces Limitations \u0026amp; constraints The Card API doesn’t allow to request the transmission to a card of the APDU commands “Select Application by DF Name” or “Get Response”:\nthe selection of a specific card application could be managed only through a Card Selection Request. the APDU response status words 61XYh \u0026amp; 6CXYh are automatically handled by the reader layer library by issuing a Get Response or by re-issuing the previous command with the expected ‘Le’ field. Implementations \u0026amp; API Documentation The third version number (x.y.z) only concerns updates of the javadoc because this component does not contain any implementation, but only an API. Java implementation 2.0.0 API documentation UML GitHub repository Changelog All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy Gradle Kotlin Maven Copy implementation \u0026#39;org.eclipse.keypop:keypop-card-java-api:2.0.0\u0026#39; implementation(\u0026#34;org.eclipse.keypop:keypop-card-java-api:2.0.0\u0026#34;) \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keypop\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keypop-card-java-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; C++ implementation 2.0.0 API documentation UML GitHub repository ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1700845823,"objectID":"99dbf5149b87168d4a1e8e272647badc","permalink":"https://keypop.org/apis/keypop-card-api/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/apis/keypop-card-api/","section":"apis","summary":"Internal API which defines the elements shared between the reader layer and the card layer.","tags":null,"title":"Keypop Card API","type":"book"},{"authors":null,"categories":null,"content":" Overview As part of the Card Layer, the Calypso Card API provides high-level functionality for selecting and performing transactions with Calypso cards.\nThe documentation for the specification produced by the Calypso Networks Association, on which this API is based, is available here.\nInterfaces The Calypso Card API provides the means to select a target card and then perform a transaction with the selected card.\nThe result of a card selection is a smartcard image whose file structure and data records can be browsed. A transaction with a target card may involve a control SAM in order to secure the operations. The CalypsoCard interfaces provide accessors in order to recover the information of the selected smart card.\nTo optimize the number of exchanges with a card reader, the Calypso Card API allows to group the commands. A set of command could be first prepared, and then be processed by a selected target at the selection or during the transaction. A transaction with a Calypso card is fully managed through the CardTransactionManager interface:\nSelection of a Calypso card A Calypso card selection could be defined to accept or not invalidated card.\nThrough the selection only basic Select File (without changing DF) or Read Records commands could joined: the goal is to recover in the selection result some file status or record data of elements present in all cards of a ticketing networks. The type of card product has not yet been identified, the commands are prepared to be supported by all types of card products: Prime, Light, or Regular.\nThen, if a Calypso card has matched the selection request, a Calypso card image is returned, some file headers or file records could be filled depending on the information recovered in the responses of the Select File or Read Records processed.\nTransaction with a Calypso card Except the operations involving secure processing on “data” (data signature computation / verification, data ciphering / un-ciphering), only commands for the card need to be prepared though the Card Transaction Manager interface. Depending on the operation, if necessary the security involving the master SAM must be controlled internally by the Calypso library.\nSimple operation outside a session PIN plain verification / change outside a session Calypso Card API - Verify / Change Plain PIN - Sequence Diagram Data secure processing outside a session Calypso Card API - Data secure processing outside a session - Sequence Diagram Key / PIN ciphered update outside a session Calypso Card API - Change Key / Ciphered PIN outside a session - Sequence Diagram Stored Value operation outside a session Calypso Card API - standalone Stored Value transaction - Sequence Diagram Simple secure session for fast embedded performance This example illustrates the ticketing processing of a validation: only the necessary data is read from the card.\nIn case of communication failure with the card, to support a recovery transaction on another terminal: the ratification status and the last event are checked at the session opening, and the session is closed as not ratified directly followed by a ratification command.\nCalypso Card API - Simple Secure Session - Sequence Diagram Simple secure session for an efficient distributed system In most of the cases, it should be possible to handle a secure session with a Calypso card, using only:\n3 exchanges with the card reader (selection processing, session opening processing, and session closing processing), and 3 exchanges with the SAM reader (terminal session challenge recovery, session MAC computation, and card authentication). This example shows the loading of a contract during a sale, to speed up the identification of the card content while limiting the exchange of messages with the card reader, some data can be read out of session during the selection, then read again during the session.\nIn case of communication failure with the card, if the recovery transaction is supported only on the same terminal, then the checking of the ratification status is not necessary at the session opening, and the session could be closed as ratified.\nCalypso Card API - Simple Secure Session - Sequence Diagram PIN ciphered verification inside a session Calypso Card API - Verify Ciphered PIN inside a session - Sequence Diagram Data secure processing inside a session Calypso Card API - Data secure processing inside a session - Sequence Diagram Stored Value operation inside a session Calypso Card API - Stored Value transaction inside a secure session - Sequence Diagram Multiple secure sessions Calypso Card API - Multiple secure session - Sequence Diagram Selection of a Calypso SAM Transaction with a Calypso SAM Implementations \u0026amp; API Documentation The third version number (x.y.z) only concerns updates of the javadoc because this component does not contain any implementation, but only an API. Java implementation 2.0.0 API documentation UML GitHub repository Changelog All deliverables are available directly from the …","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1701256646,"objectID":"674583aa63934b912a4db375ff35dec0","permalink":"https://keypop.org/apis/keypop-calypso-card-api/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/apis/keypop-calypso-card-api/","section":"apis","summary":"Public high-level API which standardizes the way to interact with a Calypso® product (card, NFC smartphone applet/application, SAM, etc...).","tags":null,"title":"Keypop Calypso Card API","type":"book"},{"authors":null,"categories":null,"content":" Overview The Calypso Crypto Symmetric API is the communication interface between the Calypso Card and the Calypso Symmetric Crypto libraries (e.g. Legacy SAM, Open SAM).\nThe documentation for the specification produced by the Calypso Networks Association, on which this API is based, is available here.\nInterfaces Implementations \u0026amp; API Documentation The third version number (x.y.z) only concerns updates of the javadoc because this component does not contain any implementation, but only an API. Java implementation 0.1.0 API documentation UML GitHub repository Changelog All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy Gradle Kotlin Maven Copy implementation \u0026#39;org.eclipse.keypop:keypop-calypso-crypto-symmetric-java-api:0.1.0\u0026#39; implementation(\u0026#34;org.eclipse.keypop:keypop-calypso-crypto-symmetric-java-api:0.1.0\u0026#34;) \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keypop\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keypop-calypso-crypto-symmetric-java-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; C++ implementation 0.1.0 API documentation UML GitHub repository ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1701256646,"objectID":"8533dac598039928522e70203db5e32b","permalink":"https://keypop.org/apis/keypop-calypso-crypto-symmetric-api/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/apis/keypop-calypso-crypto-symmetric-api/","section":"apis","summary":"Internal API which defines the elements shared between the Calypso Card and the Calypso Symmetric Crypto libraries.","tags":null,"title":"Keypop Calypso Crypto Symmetric API","type":"book"},{"authors":null,"categories":null,"content":" Overview As part of the Card Layer, the Calypso Crypto Legacy SAM API provides high-level functionality for selecting and performing transactions with Calypso Legacy SAMs and can also be coupled with the Calypso Card API to handle the cryptographic calculations required for Calypso card transactions secured by symmetric keys.\nThe documentation for the specification produced by the Calypso Networks Association, on which this API is based, is available here.\nInterfaces The Calypso Crypto Legacy SAM API provides the means to select a target or control SAM and then perform a transaction with the selected target.\nThe result of a SAM selection is a smartcard image whose keys’ parameters can be read. A transaction with a target SAM may involve a control SAM in order to secure the operations. The LegacySam interface provide accessors in order to recover the information of the selected smartcard.\nTo optimize the number of exchanges with a SAM reader, the Legacy SAM API allows to group the commands. A set of command could be first prepared, and then be processed by a selected target at the selection or during the transaction. A transaction with a Calypso SAM is fully managed through one of the LSTransactionManager interfaces:\nImplementations \u0026amp; API Documentation The third version number (x.y.z) only concerns updates of the javadoc because this component does not contain any implementation, but only an API. Java implementation 0.4.0 API documentation UML GitHub repository Changelog All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy Gradle Kotlin Maven Copy implementation \u0026#39;org.eclipse.keypop:keypop-calypso-crypto-legacysam-java-api:0.4.0\u0026#39; implementation(\u0026#34;org.eclipse.keypop:keypop-calypso-crypto-legacysam-java-api:0.4.0\u0026#34;) \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keypop\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keypop-calypso-crypto-legacysam-java-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; C++ implementation work in progress… ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1700845823,"objectID":"6166e08d9a84fae9b139d6a5485e08a2","permalink":"https://keypop.org/apis/keypop-calypso-crypto-legacysam-api/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/apis/keypop-calypso-crypto-legacysam-api/","section":"apis","summary":"Public high-level API which standardizes the way to interact with a Calypso® legacy SAM product (SAM-C1, HSM-C1, etc...).","tags":null,"title":"Keypop Calypso Crypto Legacy SAM API","type":"book"},{"authors":null,"categories":null,"content":" Overview The Calypso Crypto Asymmetric API is the communication interface between the Calypso Card and the Calypso Asymmetric Crypto libraries.\nThe documentation for the specification produced by the Calypso Networks Association, on which this API is based, is available here.\nInterfaces Implementations \u0026amp; API Documentation The third version number (x.y.z) only concerns updates of the javadoc because this component does not contain any implementation, but only an API. Java implementation 0.1.0 API documentation UML GitHub repository Changelog All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy Gradle Kotlin Maven Copy implementation \u0026#39;org.eclipse.keypop:keypop-calypso-crypto-asymmetric-java-api:0.1.0\u0026#39; implementation(\u0026#34;org.eclipse.keypop:keypop-calypso-crypto-asymmetric-java-api:0.1.0\u0026#34;) \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keypop\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keypop-calypso-crypto-asymmetric-java-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; C++ implementation 0.1.0 API documentation UML GitHub repository ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1701256646,"objectID":"f0473daa4533c1895a2daf9720eb0057","permalink":"https://keypop.org/apis/keypop-calypso-crypto-asymmetric-api/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/apis/keypop-calypso-crypto-asymmetric-api/","section":"apis","summary":"Internal API which defines the elements shared between the Calypso Card and the Calypso Asymmetric Crypto libraries.","tags":null,"title":"Keypop Calypso Crypto Asymmetric API","type":"book"}]